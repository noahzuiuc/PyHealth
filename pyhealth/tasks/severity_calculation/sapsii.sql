-- THIS SCRIPT IS AUTOMATICALLY GENERATED. DO NOT EDIT IT DIRECTLY.
DROP TABLE IF EXISTS sapsii;
CREATE TABLE sapsii AS
-- ------------------------------------------------------------------
-- Title: Simplified Acute Physiology Score II (SAPS II) - PostgreSQL Version
-- This query extracts the simplified acute physiology score II.
-- This score is a measure of patient severity of illness.
-- The score is calculated on the first day of each ICU patients' stay.
-- ------------------------------------------------------------------

-- Reference for SAPS II:
--     Le Gall, Jean-Roger, Stanley Lemeshow, and Fabienne Saulnier.
--     "A new simplified acute physiology score (SAPS II) based on a European/North American multicenter study."
--     JAMA 270, no. 24 (1993): 2957-2963.

-- Variables used in SAPS II:
--  Age, GCS
--  VITALS: Heart rate, systolic blood pressure, temperature
--  FLAGS: ventilation/cpap
--  IO: urine output
--  LABS: PaO2/FiO2 ratio, blood urea nitrogen, WBC, potassium, sodium, HCO3

-- The following views/tables are required to run this query:
--  1) urine_output_first_day - generated by urine-output-first-day.sql (adapted for PostgreSQL)
--  2) ventilation_durations - generated by ventilation_durations.sql (adapted for PostgreSQL)
--  3) vitals_first_day - generated by vitals-first-day.sql (adapted for PostgreSQL)
--  4) gcs_first_day - generated by gcs-first-day.sql (adapted for PostgreSQL)
--  5) labs_first_day - generated by labs-first-day.sql (adapted for PostgreSQL)
--  6) blood_gas_first_day_arterial - generated by blood-gas-first-day-arterial.sql (adapted for PostgreSQL)
-- Also requires base tables: icustays, chartevents, admissions, services, patients, diagnoses_icd

-- Note:
--  The score is calculated for *all* ICU patients, with the assumption that the user will subselect appropriate ICUSTAY_IDs.
--  For example, the score is calculated for neonates, but it is likely inappropriate to actually use the score values for these patients.

-- extract CPAP from the "Oxygen Delivery Device" fields
WITH cpap AS (
    SELECT
        ie.icustay_id,
        MIN(ce.charttime - INTERVAL '1 hour') AS starttime,
        MAX(ce.charttime + INTERVAL '4 hour') AS endtime,
        MAX(CASE
            WHEN LOWER(ce.value) LIKE '%cpap%' THEN 1
            WHEN LOWER(ce.value) LIKE '%bipap mask%' THEN 1
            ELSE 0
        END) AS cpap
    FROM icustays ie
    INNER JOIN chartevents ce
        ON ie.icustay_id = ce.icustay_id
        AND ce.charttime BETWEEN ie.intime AND (ie.intime + INTERVAL '1 day')
    WHERE ce.itemid IN (
        -- TODO: when metavision data import fixed, check the values in 226732 match the value clause below
        467, 469, 226732
    )
    AND (LOWER(ce.value) LIKE '%cpap%' OR LOWER(ce.value) LIKE '%bipap mask%')
    -- exclude rows marked as error
    AND (ce.error IS NULL OR ce.error = 0)
    GROUP BY ie.icustay_id
),

-- extract a flag for surgical service
-- this combined with "elective" FROM admissions table defines elective/non-elective surgery
surgflag AS (
    SELECT
        adm.hadm_id,
        CASE WHEN LOWER(curr_service) LIKE '%surg%' THEN 1 ELSE 0 END AS surgical,
        ROW_NUMBER() OVER (PARTITION BY adm.hadm_id ORDER BY transfertime) AS serviceorder
    FROM admissions adm
    LEFT JOIN services se
        ON adm.hadm_id = se.hadm_id
),

-- icd-9 diagnostic codes are our best source for comorbidity information
-- unfortunately, they are technically a-causal
-- however, this shouldn't matter too much for the SAPS II comorbidities
comorb AS (
    SELECT
        hadm_id,
        -- these are slightly different than elixhauser comorbidities, but based on them
        -- they include some non-comorbid ICD-9 codes (e.g. 20302, relapse of multiple myeloma)
        MAX(CASE
            WHEN SUBSTRING(icd9_code FROM 1 FOR 3) BETWEEN '042' AND '044' THEN 1
            ELSE 0
        END) AS aids, /* HIV and AIDS */
        MAX(CASE
            WHEN icd9_code BETWEEN '20000' AND '20238' THEN 1 -- lymphoma
            WHEN icd9_code BETWEEN '20240' AND '20248' THEN 1 -- leukemia
            WHEN icd9_code BETWEEN '20250' AND '20302' THEN 1 -- lymphoma
            WHEN icd9_code BETWEEN '20310' AND '20312' THEN 1 -- leukemia
            WHEN icd9_code BETWEEN '20302' AND '20382' THEN 1 -- lymphoma
            WHEN icd9_code BETWEEN '20400' AND '20522' THEN 1 -- chronic leukemia
            WHEN icd9_code BETWEEN '20580' AND '20702' THEN 1 -- other myeloid leukemia
            WHEN icd9_code BETWEEN '20720' AND '20892' THEN 1 -- other myeloid leukemia
            WHEN SUBSTRING(icd9_code FROM 1 FOR 4) = '2386' THEN 1 -- lymphoma
            WHEN SUBSTRING(icd9_code FROM 1 FOR 4) = '2733' THEN 1 -- lymphoma
            ELSE 0
        END) AS hem,
        MAX(CASE
            WHEN SUBSTRING(icd9_code FROM 1 FOR 4) BETWEEN '1960' AND '1991' THEN 1
            WHEN icd9_code BETWEEN '20970' AND '20975' THEN 1
            WHEN icd9_code = '20979' THEN 1
            WHEN icd9_code = '78951' THEN 1
            ELSE 0
        END) AS mets /* Metastatic cancer */
    FROM diagnoses_icd
    GROUP BY hadm_id
),

pafi1 AS (
    -- join blood gas to ventilation durations to determine if patient was vent
    -- also join to cpap table for the same purpose
    SELECT
        bg.icustay_id,
        bg.charttime,
        bg.pao2fio2, -- Assuming this column exists in blood_gas_first_day_arterial
        CASE WHEN vd.icustay_id IS NOT NULL THEN 1 ELSE 0 END AS vent,
        CASE WHEN cp.icustay_id IS NOT NULL THEN 1 ELSE 0 END AS cpap
    FROM blood_gas_first_day_arterial bg -- This needs to be a table/view in PostgreSQL
    LEFT JOIN ventilation_durations vd -- This needs to be a table/view in PostgreSQL
        ON bg.icustay_id = vd.icustay_id
        AND bg.charttime >= vd.starttime
        AND bg.charttime <= vd.endtime
    LEFT JOIN cpap cp
        ON bg.icustay_id = cp.icustay_id
        AND bg.charttime >= cp.starttime
        AND bg.charttime <= cp.endtime
),

pafi2 AS (
    -- get the minimum PaO2/FiO2 ratio *only for ventilated/cpap patients*
    SELECT
        icustay_id,
        MIN(pao2fio2) AS pao2fio2_vent_min
    FROM pafi1
    WHERE vent = 1 OR cpap = 1
    GROUP BY icustay_id
),

cohort AS (
    SELECT
        ie.subject_id,
        ie.hadm_id,
        ie.icustay_id,
        ie.intime,
        ie.outtime,

        -- Calculate age using PostgreSQL AGE function and EXTRACT
        EXTRACT(YEAR FROM AGE(ie.intime, pat.dob)) AS age,

        vital.heartrate_max,
        vital.heartrate_min,
        vital.sysbp_max,
        vital.sysbp_min,
        vital.tempc_max,
        vital.tempc_min,

        -- this value is non-null iff the patient is on vent/cpap
        pf.pao2fio2_vent_min,

        uo.urineoutput,

        labs.bun_min,
        labs.bun_max,
        labs.wbc_min,
        labs.wbc_max,
        labs.potassium_min,
        labs.potassium_max,
        labs.sodium_min,
        labs.sodium_max,
        labs.bicarbonate_min,
        labs.bicarbonate_max,
        labs.bilirubin_min,
        labs.bilirubin_max,

        gcs.mingcs,

        -- Ensure comorbidities are treated as 0 if NULL
        COALESCE(comorb.aids, 0) AS aids,
        COALESCE(comorb.hem, 0) AS hem,
        COALESCE(comorb.mets, 0) AS mets,

        CASE
            WHEN adm.admission_type = 'ELECTIVE' AND sf.surgical = 1 THEN 'ScheduledSurgical'
            WHEN adm.admission_type != 'ELECTIVE' AND sf.surgical = 1 THEN 'UnscheduledSurgical'
            ELSE 'Medical'
        END AS admissiontype

    FROM icustays ie
    INNER JOIN admissions adm ON ie.hadm_id = adm.hadm_id
    INNER JOIN patients pat ON ie.subject_id = pat.subject_id
    -- join to above views/tables
    LEFT JOIN pafi2 pf ON ie.icustay_id = pf.icustay_id
    LEFT JOIN surgflag sf ON adm.hadm_id = sf.hadm_id AND sf.serviceorder = 1
    LEFT JOIN comorb ON ie.hadm_id = comorb.hadm_id
    -- join to custom tables to get more data....
    LEFT JOIN gcs_first_day gcs ON ie.icustay_id = gcs.icustay_id -- This needs to be a table/view in PostgreSQL
    LEFT JOIN vitals_first_day vital ON ie.icustay_id = vital.icustay_id -- This needs to be a table/view in PostgreSQL
    LEFT JOIN urine_output_first_day uo ON ie.icustay_id = uo.icustay_id -- This needs to be a table/view in PostgreSQL
    LEFT JOIN labs_first_day labs ON ie.icustay_id = labs.icustay_id -- This needs to be a table/view in PostgreSQL
),

scorecomp AS (
    SELECT
        cohort.*,
        -- Below code calculates the component scores needed for SAPS II
        CASE
            WHEN age IS NULL THEN NULL
            WHEN age < 40 THEN 0
            WHEN age < 60 THEN 7
            WHEN age < 70 THEN 12
            WHEN age < 75 THEN 15
            WHEN age < 80 THEN 16
            WHEN age >= 80 THEN 18
        END AS age_score,

        CASE
            WHEN heartrate_max IS NULL OR heartrate_min IS NULL THEN NULL
            WHEN heartrate_min < 40 THEN 11
            WHEN heartrate_max >= 160 THEN 7
            WHEN heartrate_max >= 120 THEN 4
            WHEN heartrate_min < 70 THEN 2
            WHEN heartrate_max >= 70 AND heartrate_max < 120 AND heartrate_min >= 70 AND heartrate_min < 120 THEN 0
            ELSE NULL -- Added default NULL for unhandled cases if any
        END AS hr_score,

        CASE
            WHEN sysbp_min IS NULL OR sysbp_max IS NULL THEN NULL
            WHEN sysbp_min < 70 THEN 13
            WHEN sysbp_min < 100 THEN 5
            WHEN sysbp_max >= 200 THEN 2
            WHEN sysbp_max >= 100 AND sysbp_max < 200 AND sysbp_min >= 100 AND sysbp_min < 200 THEN 0
            ELSE NULL -- Added default NULL for unhandled cases if any
        END AS sysbp_score,

        CASE
            WHEN tempc_max IS NULL OR tempc_min IS NULL THEN NULL -- Ensure min is checked if max isn't triggering score > 0
            WHEN tempc_max >= 39.0 THEN 3
            WHEN tempc_min < 39.0 THEN 0 -- Original logic only cared about >= 39
            ELSE 0 -- Default case if temp is within range
        END AS temp_score, -- Note: Original logic only assigned points for >= 39.0

        CASE
            WHEN pao2fio2_vent_min IS NULL THEN NULL
            WHEN pao2fio2_vent_min < 100 THEN 11
            WHEN pao2fio2_vent_min < 200 THEN 9
            WHEN pao2fio2_vent_min >= 200 THEN 6
        END AS pao2fio2_score,

        CASE
            WHEN urineoutput IS NULL THEN NULL
            WHEN urineoutput < 500.0 THEN 11
            WHEN urineoutput < 1000.0 THEN 4
            WHEN urineoutput >= 1000.0 THEN 0
        END AS uo_score,

        CASE
            WHEN bun_max IS NULL THEN NULL
            WHEN bun_max < 28.0 THEN 0 -- Assuming bun_min doesn't influence the score here based on original logic
            WHEN bun_max < 84.0 THEN 6
            WHEN bun_max >= 84.0 THEN 10
        END AS bun_score,

        CASE
            WHEN wbc_max IS NULL OR wbc_min IS NULL THEN NULL
            WHEN wbc_min < 1.0 THEN 12
            WHEN wbc_max >= 20.0 THEN 3
            WHEN wbc_max >= 1.0 AND wbc_max < 20.0 AND wbc_min >= 1.0 AND wbc_min < 20.0 THEN 0
            ELSE NULL -- Should cover cases where one is NULL or range is mixed (e.g., min<1, max<20) - SAPS II might need explicit handling here if needed
        END AS wbc_score,

        CASE
            WHEN potassium_max IS NULL OR potassium_min IS NULL THEN NULL
            WHEN potassium_min < 3.0 THEN 3
            WHEN potassium_max >= 5.0 THEN 3
            WHEN potassium_max >= 3.0 AND potassium_max < 5.0 AND potassium_min >= 3.0 AND potassium_min < 5.0 THEN 0
            ELSE 3 -- If min >= 3.0 and max >= 5.0 OR min < 3.0 and max < 5.0 (score is 3)
        END AS potassium_score,

        CASE
            WHEN sodium_max IS NULL OR sodium_min IS NULL THEN NULL
            WHEN sodium_min < 125 THEN 5
            WHEN sodium_max >= 145 THEN 1
            WHEN sodium_max >= 125 AND sodium_max < 145 AND sodium_min >= 125 AND sodium_min < 145 THEN 0
            -- Handle cases where range overlaps boundaries, choose higher score per SAPS II logic if ambiguous
            WHEN sodium_min < 125 AND sodium_max >= 145 THEN 5 -- min < 125 is higher score
            WHEN sodium_min < 125 AND sodium_max < 145 THEN 5 -- min < 125 is higher score
            WHEN sodium_min >= 125 AND sodium_max >= 145 THEN 1 -- max >= 145 is higher score here
            ELSE NULL -- Should not happen if min <= max
        END AS sodium_score,

        CASE
            WHEN bicarbonate_max IS NULL OR bicarbonate_min IS NULL THEN NULL
            WHEN bicarbonate_min < 15.0 THEN 5
            WHEN bicarbonate_min < 20.0 THEN 3 -- This implies 15.0 <= bicarbonate_min < 20.0
            WHEN bicarbonate_min >= 20.0 THEN 0 -- Assumes max doesn't play a role if min >= 20
            ELSE NULL
        END AS bicarbonate_score, -- Note: Original logic focuses on min value.

        CASE
            WHEN bilirubin_max IS NULL THEN NULL -- Score based on max value
            WHEN bilirubin_max < 4.0 THEN 0
            WHEN bilirubin_max < 6.0 THEN 4 -- This implies 4.0 <= bilirubin_max < 6.0
            WHEN bilirubin_max >= 6.0 THEN 9
        END AS bilirubin_score,

        CASE
            WHEN mingcs IS NULL THEN NULL
            WHEN mingcs < 3 THEN NULL -- erroneous value/on trach
            WHEN mingcs < 6 THEN 26
            WHEN mingcs < 9 THEN 13
            WHEN mingcs < 11 THEN 7
            WHEN mingcs < 14 THEN 5
            WHEN mingcs >= 14 AND mingcs <= 15 THEN 0
            ELSE NULL -- Should not happen for GCS range 3-15
        END AS gcs_score,

        CASE
            WHEN aids = 1 THEN 17
            WHEN hem = 1 THEN 10
            WHEN mets = 1 THEN 9
            ELSE 0
        END AS comorbidity_score,

        CASE
            WHEN admissiontype = 'ScheduledSurgical' THEN 0
            WHEN admissiontype = 'Medical' THEN 6
            WHEN admissiontype = 'UnscheduledSurgical' THEN 8
            ELSE NULL
        END AS admissiontype_score

    FROM cohort
),

-- Calculate SAPS II here so we can use it in the probability calculation below
score AS (
    SELECT
        s.*,
        -- coalesce statements impute normal score of zero if data element is missing
        COALESCE(age_score, 0)
        + COALESCE(hr_score, 0)
        + COALESCE(sysbp_score, 0)
        + COALESCE(temp_score, 0)
        + COALESCE(pao2fio2_score, 0)
        + COALESCE(uo_score, 0)
        + COALESCE(bun_score, 0)
        + COALESCE(wbc_score, 0)
        + COALESCE(potassium_score, 0)
        + COALESCE(sodium_score, 0)
        + COALESCE(bicarbonate_score, 0)
        + COALESCE(bilirubin_score, 0)
        + COALESCE(gcs_score, 0)
        + COALESCE(comorbidity_score, 0)
        + COALESCE(admissiontype_score, 0)
        AS sapsii
    FROM scorecomp s
)

-- Final selection joining back to icustays to ensure all stays are included
SELECT
    ie.subject_id,
    ie.hadm_id,
    ie.icustay_id,
    s.sapsii,
    -- Calculate sapsii probability using PostgreSQL LN function
    CASE
      WHEN s.sapsii IS NULL OR s.sapsii < 0 THEN NULL -- Avoid LN(negative or zero)
      ELSE 1.0 / (1.0 + EXP(- (-7.7631 + 0.0737 * (s.sapsii) + 0.9971 * (LN(s.sapsii + 1)))))
    END as sapsii_prob,
    s.age_score,
    s.hr_score,
    s.sysbp_score,
    s.temp_score,
    s.pao2fio2_score,
    s.uo_score,
    s.bun_score,
    s.wbc_score,
    s.potassium_score,
    s.sodium_score,
    s.bicarbonate_score,
    s.bilirubin_score,
    s.gcs_score,
    s.comorbidity_score,
    s.admissiontype_score
FROM icustays ie
LEFT JOIN score s ON ie.icustay_id = s.icustay_id
ORDER BY ie.icustay_id;